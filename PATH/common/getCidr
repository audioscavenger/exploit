#!/usr/bin/env bash
# this will resolve an IP to its owner's CIDR and append a file; takes one IP or a file as input

########
# INIT ###########################################################################
########
thisVersion=1.0.0
typeset TMP range cidr net cidrs IP INPUT OUTPUT

TMP=$(mktemp -t getCidr.XXXXXXX)
sleepRange=1-20
largestCidr=13

# getopts:
typeset _NOARGS _OPT OPTIND
while getopts :i:o:DV _OPT 2>/dev/null
do
{
  case ${_OPT} in
    i) INPUT="${OPTARG}" ;;
    o) OUTPUT="${OPTARG}" ;;
    V) Verbose=true ;;
    D) Debug=true && Verbose=true ;;
    *) _NOARGS="${_NOARGS}${_NOARGS+, }-${OPTARG}" ;;
  esac
}
done
shift $((OPTIND - 1))
unset _OPT OPTARG
# [ "X${_NOARGS}" != "X" ] && ERROR param "${_NOARGS}"

typeset IP="$*"

########
# VERIF ###########################################################################
########

# if [ $# -lt 1 -o "X${_NOARGS}" != "X" ]; then
if [ $OPTIND -lt 1 ]; then
  echo2 "\
${C}getCidr ${w}[OPTIONS] ${c}< IP,.. | -i INPUTfile > ${END}\n\
  -i              INPUT file of IPs \n\
  -o              OUTPUT file of cidr \n\
  -V              VERBOSE mode \n\
  -D              DEBUG mode \n\
"
  exit 99
fi


[ -n "${INPUT}" -a ! -s "${INPUT}" ] && ERROR exist "${INPUT}" 0 && exit 1
[ -z "${INPUT}" ] && INPUT=$(mktemp -t getCidr.INPUT.XXXXXXX) && echo $* | tr ' ' '\n' >${INPUT}
[ -z "${OUTPUT}" ] && OUTPUT=$(mktemp -t getCidr.OUTPUT.XXXXXXX)

########
# FUNC ###########################################################################
########
function get_cidr()
{
  local ip=$1
  local _ip _cidr
  local color=${g}
  
  # first let's try all the cidrs we already have, then exit main loop
  # NO CAN DO - some IP are within super CIDR such as 101.100.165.23 in 101.64.0.0/10 tht encompasses AFRINIC as well... no one know who's IP it is... yaya...
  for net in ${cidrs}; do 
    if (is_ip_in_cidr ${ip} ${net}); then
      # cidr found in cidrs, now grab its contact values; If IP only, cidrs won't be updated and OUTPUT can only but exist
      while IFS=";" read -r _ip _cidr country netname notify abusemailbox email phone person; do show_and_update ${color}; done <<<$(grep ";${net};" ${OUTPUT} | head -1)
      return 0
    fi
  done

  # each whois call gets us closer to a temporary ban and should be avoided at all costs
  if [ ! -s "/tmp/whois.${ip}.txt" ]; then
    $Verbose && echo2 "VERBOSE: ${c}whois -HI $ip >/tmp/whois.${ip}.txt"${END}
    whois -HI $ip >/tmp/whois.${ip}.txt
    color=${G}
  fi
  
  local cidr=$(awk '/^route:|^CIDR:/ {print $2}' /tmp/whois.${ip}.txt | tr -d ','); 
  local country=$(awk '/^country:|^Country:/ {print $2}' /tmp/whois.${ip}.txt | head -1); 
  local netname=$(awk '/^netname:|^NetName:/ {print $2}' /tmp/whois.${ip}.txt | head -1); 
  local notify=$(awk '/^notify:|^OrgNOCEmail:/ {print $2}' /tmp/whois.${ip}.txt | sort | uniq | tr '\n' ','); 
  local abusemailbox=$(awk '/^abuse-mailbox:|^OrgAbuseEmail:/ {print $2}' /tmp/whois.${ip}.txt | sort | uniq | tr '\n' ','); 
  local email=$(awk '/^e-mail:|^OrgTechEmail:/ {print $2}' /tmp/whois.${ip}.txt | sort | uniq | tr '\n' ','); 
  local phone=$(awk '/^phone:|^OrgAbusePhone:/ {$1=""; print}' /tmp/whois.${ip}.txt | grep -v 000000000 | sort | uniq | tr '\n' ','); 
  local person=$(awk '/^person:|^OrgAbuseName:/ {$1=""; print}' /tmp/whois.${ip}.txt | sort | uniq | tr '\n' ','); 
  $Verbose && echo2 "VERBOSE: $ip route: ${cidr} country: ${country} netname: ${netname} notify: ${notify} abuse-mailbox: ${abusemailbox} e-mail: ${email} phone: ${phone} person: ${person}"
  
  if [ -z "${cidr}" ]; then
    range=$(awk '/^inetnum:|^NetRange:/ {print $2,$3,$4}' /tmp/whois.${ip}.txt)
    $Verbose && echo2 "VERBOSE: $ip inetnum: ${range}"
    
    # ipcalc can return multiple lines! example for TAIWAN: 100.43.96.0 101.55.255.255
    [ -n "${range}" ] && cidr=$(ipcalc -r ${range} | grep -v deaggregate); 
  fi
  
  if [ -z "${cidr}" ]; then
    ERROR whois "no cidr for $ip - are your rate-limited?" 1
    exit 1
  else
    for net in ${cidr}; do
      $Verbose && echo2 "VERBOSE: is_ip_in_cidr ${ip} ${net}"
      is_ip_in_cidr ${ip} ${net} && show_and_update ${color} && break
    done
  fi
  
  sleep $(shuf -i ${sleepRange} -n 1)
  return 0
}

function show_and_update()
{
  echo -n $1 && echo "${ip};${net};${country};${netname};${notify};${abusemailbox};${email};${phone};${person}" | tee -a ${OUTPUT} && echo -n ${END}
  
  # add this net to cidrs if not exist AND OUTPUT file is provided
  # NO CAN DO because some cidr are continental and useless to compare to: /8 /10 etc
  # we limit down to /13
  append_cidr ${net}
  
  return 0
}

function append_cidr()
{
  local _net=$1
  # [[ "${cidrs}" == "${cidrs##*$_net}" ]] && (( ${_net#*/} >= ${largestCidr} )) && cidrs+=" ${_net}" && $Verbose && echo "VERBOSE: adding net=${_net}"
  # [[ "${cidrs}" == "${cidrs##*$_net}" ]] && cidrs+=" ${_net}"                                             # takes 30ms, too long
  (echo ${cidrs} | grep -vq ${_net}) && (( ${_net#*/} >= ${largestCidr} )) && cidrs+=" ${_net}" && $Verbose && echo "VERBOSE: adding net=${_net}"
  return 0
}

# https://serverfault.com/questions/1120769/check-if-ip-belongs-to-a-cidr
function is_ip_in_cidr()
{
  local ip=$1
  local cidr=$2

  #Process the CIDR first
  local network=$(echo $cidr | cut -d/ -f1)
  local mask=$(echo $cidr | cut -d/ -f2)

  #Quad dot notation has 4 fields. Shift and add to give decimal number
  local network_dec=$(echo $network | awk -F. '{printf("%d\n", (($1 * 256 +$2) * 256 + $3) * 256 + $4) }')
  # $Debug && echo2 "DEBUG: network_dec: $network_dec"

  #Shift bitmask correct number of places for given mask
  local mask_dec=$((0xffffffff << (32 - $mask)))

  # $Debug && echo2 "DEBUG: local mask_dec=$((0x0000000f << (32 - $mask)))"
  # $Debug && printf "DEBUG: mask_dec: %x\n", $mask_dec

  #But limit bitmask to 32 bits or 8 hexidecimal places.
  local mask_dec2=$((0xffffffff & $mask_dec))
  # $Debug && printf "DEBUG: mask_dec2: %x\n", $mask_dec2

  #Apply mask to network address to get the bits to check
  local net1=$(( $mask_dec2 & $network_dec ))
  # $Debug && printf "DEBUG: net1: %x\n", $net1

  #Process the IP address. Again Quad dot notation, shift and add.
  local ip_dec=$(echo $ip | awk -F. '{printf("%d\n", (($1 * 256 +$2) * 256 + $3) * 256 + $4) }')
  # $Debug && echo2 "DEBUG: IP DEC: $ip_dec"

  #Apply the same mask to IP address
  local net2=$(( $mask_dec2 & $ip_dec ))
  # $Debug && printf "DEBUG: net2: %x\n", $net2

  #Now the two network components can be compared
  if [[ $net1 == $net2 ]]; then
    return 0
  else
    return 1
  fi
}

########
# MAIN ###########################################################################
########

# first let's gather all the cidr we already have and initialize OUTPUT if necessary
# NO CAN DO because some cidr are continental and useless to compare to
# so we limit down to /13 as the largest
if [ -s ${OUTPUT} ]; then
  if (( $(wc -l <${OUTPUT}) > 1 )); then
    time for net in $(cut -d ';' -f 2 ${OUTPUT} | sort | uniq); do
      (( ${net#*/} >= ${largestCidr} )) && cidrs+=" ${net}"
    done
    echo2 "VERBOSE: cidrs in stock: ${cidrs}"
    sleep 3
  else
    echo "ip;cidr;country;netname;notify;abusemailbox;email;phone;person" >${OUTPUT}
  fi
fi

# for each IP...
while read ip; do 
  
  # if IP not in OUTPUT or OUTPUT is empty...
  grep "^${ip};" ${OUTPUT} 2>/dev/null || get_cidr ${ip}
  
done <${INPUT}

exit 0

