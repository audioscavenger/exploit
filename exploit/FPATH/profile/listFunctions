listFunctions() {
#@(t)  |UNAME |out|mod|set|sys|net|app|mis| description                                                                                        |
#@(p)  |*     | x |   |   |   |   |   | x | profile: list available FPATH functions called functions in a script, or function usages           |
local ARGS
# getopts:
local _OPT _NOARGS OPTARG OPTIND
while getopts ymckg _OPT 2>/dev/null
do
{
  case ${_OPT} in
    *) ARGS="$ARGS-${_OPT} " ;;
  esac
}
done
shift $((OPTIND - 1))
unset _OPT OPTARG OPTIND
# [ "X${_NOARGS}" != "X" ] && ERROR param "${_NOARGS}"

! (($#)) && echo2 "${C}${FUNCNAME}${c} [-ymckg] <\"fpath\" | [-f] (script2check|function) | \"usage\" [funcDir [pattern]]>${END}" && return 99
[ -z "$FPATH" ] && echo2 "ERROR: FPATH not set..." && return 1

local fpath fpaths func FUNCPATHS script scriptType FULL mainFUNCPATH mainFUNC subFUNCS subFUNC pattern
fpaths=${FPATH/#:/.:}
fpaths=${fpaths//::/:.:}
fpaths=${fpaths/%:/:.}
fpaths=${fpaths//:/ }
FULL=false
[ "x$1" == "x-f" ] && FULL=true && shift
[ "x$1" == "xfpath" ] && for fpath in ${fpaths}; do [ -n "$2" -a "${fpath##*/}" != "$2" ] && continue; echo "${g8}${fpath}:${w}" && command ls -c ${fpath}; done && return 0

if [ "x$1" == "xusage" ]; then
  [ -n "$3" ] && pattern=$3
  printf "${SMUL}%-25s  |UNAME |out|mod|set|sys|net|app|mis| description                                                                                        ${RMUL}|\n" "funcName"
  for fpath in ${fpaths}; do
    ## if $2 and current fpath folder == $2, then grep #@(p) in the functions of that folder; else continue
    [ -n "$2" -a "${fpath##*/}" != "$2" ] && continue
    #${awk} '/^#@\(p\)/ {sub(/^#@\(p\)/,"",$0); n=split(FILENAME,filename,"/"); printf "%-25s%s\n",filename[n],$0}' ${fpath}/*${pattern}* 2>/dev/null
    ${awk} '{
      if (/^#@\(p\)/) {sub(/^#@\(p\)/,"",$0); n=split(FILENAME,filename,"/"); printf "%-25s%s\n",filename[n],$0; nextfile}
      if (FNR>3) {n=split(FILENAME,filename,"/"); printf "%-25s  |      |   |   |   |   |   |   |   | %-99s|\n",filename[n],"HEADER TODO"; nextfile}
      }' ${fpath}/*${pattern}* 2>/dev/null
  done | alternate $ARGS
  return 0
fi

script="$1"
if (type -t ${script} | grep -q function); then
  scriptType=function
else
  [ ! -s "${script}" ] && ERROR exist "${script}" 0 && return 2
fi

## build FUNCPATHS with list of calls to FPATH functions in the script/functions
printf ${w}
for fpath in ${fpaths}; do
  for func in $(command ls ${fpath}); do
    if [ "${scriptType}" == "file" ]; then
      grep -wq ${func} "${script}" && FUNCPATHS="${fpath}/${func} ${FUNCPATHS}"
    else
      type ${script} | grep -wq ${func} && FUNCPATHS="${fpath}/${func} ${FUNCPATHS}"
    fi
  done
done

FUNCPATHS=$(printf "%s\n" ${FUNCPATHS} | sort)

## if -f, process found functions to find inter function-calls between functions
if $FULL && test "${FUNCPATHS}"; then
  echo "${g}$(echo ${FUNCPATHS} | wc -w) functions found. ${w}Processing sub functions...${END}"
  for mainFUNCPATH in ${FUNCPATHS}; do
    printf "${w}%s${g8}\n" ${mainFUNCPATH}
    mainFUNC=${mainFUNCPATH##*/}
    for fpath in ${fpaths}; do
      for subFUNC in $(command ls ${fpath}); do
        [ "${subFUNC}" == "${mainFUNC}" ] || [[ "${subFUNCS}" =~ "${subFUNC} " ]] && continue
        grep -wq ${subFUNC} ${mainFUNCPATH} && echo ${fpath}/${subFUNC} && subFUNCS="${subFUNC} ${subFUNCS}"
      done
    done
  done
else
  printf "${w}%s\n" ${FUNCPATHS}
fi
}
