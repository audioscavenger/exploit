" http://phdru.name/Software/dotfiles/vimrc.html
"
" User configuration file for Vi IMproved
"
" Text version here
"
" Generated by gvim :runtime syntax/2html.vim
"
" A number of scripts mentioned in the file are available here.
"
" User configuration file for Vi IMproved.
"
" vim 6.0+ required, 7.0+ recommended.

" 1 important

" Remove ALL autocommands in case the file is sourced for the second time
autocmd!

language messages C " Print messages in English

if exists("b:wrap") " Only do this on the second and subsequent :source's
   let fenc = &fileencoding
   let ftype = &filetype
   let mod = &modified
   set all& " Reset all options, except terminal options, to their default value.
   execute 'set fileencoding=' . fenc
   execute 'set filetype=' . ftype
   if mod
      set modified
   else
      set nomodified
   endif
   unlet fenc ftype mod
endif

" No, it is not VI, it is VIM! It is important to set this first, because this
" command resets many other options.
set nocompatible

" Set behavior to xterm, not mswin
behave xterm

" 2 moving around, searching and patterns

set ignorecase    " Ignore case in search patterns
set smartcase     " Match 'word' case-insensitive and 'Word' case-sensitive

set nostartofline " Keep cursor's column
set whichwrap=b,s,h,l,<,>,[,],~ " Wrap to the previous/next line on all keys and ~ command

" 4 displaying text

set display=lastline,uhex " Show the last line instead of '@'; show non-printable chars as <hex>
set lazyredraw    " Do not update screen while executing macros
set list          " listchars only works with 'list'
set listchars=tab:>_,trail:_,extends:+ " Show tabs, trailing spaces, long lines
set wrap          " Visually wrap long lines

" With 'set wrap' wrap long lines at a character in 'breakat'
" Please note 'nolist' is required to use 'linebreak'
set linebreak showbreak=+\ " A plus and a space

set sidescroll=1  " The minimal number of columns to scroll horizontally

" 5 highlighting

set nohlsearch    " Stop the search highlighting

" 6 multiple windows

set hidden        " Don't unload a buffer when no longer shown in a window; allow to switch between buffers/windows when the buffer is modified
set laststatus=2  " Always show status line

set splitbelow    " A new window is put below of the current one
set splitright    " A new window is put right of the current one

" 8 terminal

set ttyfast       " terminal connection is fast

set title         " Set title to the value of 'titlestring' or to 'filename - VIM'
set titleold=     " string to restore the title to when exiting Vim

" 9 using the mouse

set mouse=ar      " Use mouse in all modes, plus hit-return

" 12 messages and info

set ruler         " Show cursor position below each window
set showcmd       " Show (partial) command keys in the status line

" Short message for [Modified];
" overwrite message for writing a file with subsequent message;
" truncate long file messages
set shortmess=mot

" 14 editing text

set backspace=indent,eol,start
set complete+=k   " Scan spell dictionaries for completion in addition to standard places
set infercase     " adjust case of a keyword completion match
set nojoinspaces  " Do not insert two spaces after a '.', '?' and '!' with a join command
set nrformats=hex " I seldom edit octal numbers, but very often dates like 2001-02-01

" Default value 'croql' is a compromise for both natural and programming
" languages, but as any compromise it works good for neither natural nor
" programming languages. This value is good for natural texts,
" let ftplugins to set values suitable for programming languages.
set formatoptions=2t " list of flags that tell how automatic formatting works

" 15 tabs and indenting

set expandtab     " expand <Tab> to spaces in Insert mode
set shiftwidth=3  " number of spaces used for each step of (auto)indent
set smarttab      " a <Tab> in an indent inserts 'shiftwidth' spaces
set softtabstop=3 " number of spaces to insert for a <Tab>

set noautoindent  " Do not automatically set the indent of a new line

" 18 mapping

set timeout timeoutlen=3000 " allow timing out up to 3 seconds halfway into a mapping

" 21 command line editing

set history=1000  " how many command lines are remembered
set suffixes+=.pyc,.pyo " list of file name extensions that have a lower priority
set wildignore+=*.py[co] " Ignore these patterns when completing file names
set wildmenu      " command-line completion shows a list of matches
set wildmode=longest,list:longest,full " Bash-vim completion behavior

" 22 executing external commands

if has("filterpipe")
   set noshelltemp " Use pipes on Unix
endif

" 25 multi-byte characters

" Automatically detected character encodings
set fileencodings=ucs-bom,us-ascii,utf-8,koi8-r,cp1251,cp866,latin1

" 26 various

" ! - when included, save and restore global variables that start
"     with an uppercase letter, and don't contain a lowercase letter;
" h - disable the effect of 'hlsearch';
" ' - number of files for which the marks are remembered;
" " and < - maximum number of lines saved for a register;
" s - maximum size of an item in Kbytes.
if version < 603
   set viminfo=!,h,'50,\"1000
else
   set viminfo=!,h,'50,<1000,s10
endif

" c - convert viminfo to the current encoding;
if has("iconv")
   set viminfo^=c
endif

" Removable media paths
if has("win32")
   set viminfo+=ra:,rb:
endif

" ----------

if has("gui_running")
   set background=light

   if has("win32")
      "set guifont=Courier_New:h18:cRUSSIAN
      set guifont=Lucida_Console:h18:cRUSSIAN
   else
      set guifont=Monospace\ 18
      set toolbar=icons,text " how to show the toolbar
   endif

   " set guicursor+=a:blinkon0 " Stop cursor blinking

   " Make shift-insert work like in Xterm
   " map <S-Insert> <MiddleMouse>
   " map! <S-Insert> <MiddleMouse>


   " Set nice colors
   " Background for normal text is light grey
   " Cursor is green
   " Text below the last line is darker grey
   " Status line is bright white on blue
   highlight Normal guibg=grey90
   highlight Cursor guibg=green guifg=NONE
   highlight NonText guibg=grey80
   highlight Constant guibg=grey90
   highlight Special gui=NONE guibg=grey90
   highlight StatusLine gui=bold guifg=white guibg=blue

   " ----------
   " From http://slobin.pp.ru/vim/_vimrc.html

   " Arrows should go into wrapped lines, but not while popup menu is visible
   imap <expr> <Down> pumvisible() ? "<Down>" : "<C-O>gj"
   imap <expr> <Up> pumvisible() ? "<Up>" : "<C-O>gk"

   " The <CR> key should select from completion menu without adding a newline
   imap <expr> <CR> pumvisible() ? "<C-Y>" : "<CR>"
   " ----------
else

   if (&term =~ "linux") || ($BACKGROUND == 'DARK') || ($BACKGROUND == 'dark')
         \ || has("win32")
      " Background of the terminal is black or dark grey
      set background=dark
   else
      set background=light
   endif

   if (&term =~ "linux")
      set <BS>=<7f>
   else
      highlight MoreMsg cterm=bold ctermfg=NONE
      highlight Question cterm=bold ctermfg=NONE
   endif

   if (&term =~ "term") || (&term =~ "rxvt") || (&term =~ "vt100") || (&term =~ "screen")
      set <BS>=<7f>

      " 'autoselect' to always put selected text on the clipboard;
      " 'unnamed' to use the * register like unnamed register '*'
      " for all yank, delete and put operations;
      " This allows to use mouse for copy/paste in local xterm,
      " but prevents to save the unnamed register between sessions.
      " set clipboard=autoselect,unnamed,exclude:cons\|linux

      if has ("terminfo")
         " set t_Co=256
         set t_Co=16
      else
         set t_Co=8
         set t_Sf=<Esc>[3%dm
         set t_Sb=<Esc>[4%dm
      endif
   endif

   if (&term =~ "screen")
      set ttymouse=xterm " Enable mouse codes under GNU screen
   endif
endif

highlight SpellBad term=underline cterm=NONE ctermfg=white ctermbg=red guifg=white guibg=red " gui=undercurl guisp=red
highlight StatusLine cterm=bold ctermfg=white ctermbg=blue gui=NONE guifg=white guibg=blue
highlight Visual cterm=NONE ctermfg=white ctermbg=blue gui=NONE guifg=white guibg=blue " Selection highlighting

" Multiline comments often confuse vim syntax highlighting - these maps
" allow to resynchronize; the first is faster, the second is more thorough
nmap \sc :syntax sync clear<Enter>
nmap \ss :syntax sync fromstart<Enter>


" AUTOCOMMANDS

" Enable filetype detection
filetype plugin indent on

" Reread me after editing
autocmd BufWritePost ~/.vimrc source ~/.vimrc | syntax on

if version >= 700
" Save all files before running any quickfix command (grep, makeprg, etc.)
autocmd QuickFixCmdPre * wall
endif

" Syntax highlighting
autocmd BufReadPost * syntax on


" Restore last known cursor position
function! RestorePosition()
   if exists('b:position_restored')
      return
   endif

   if line("'\"") > 0
      call cursor(line("'\""), col("'\""))
   endif
   let b:position_restored = 1
endfunction

" When editing a file, always jump to the last cursor position (if saved)
autocmd BufReadPost * call RestorePosition()


function! SetupEncoding(encoding)
   if !has("iconv") || exists('b:encoding_set')
      return
   endif

   if strlen(a:encoding) > 0
      call RestorePosition()
      let b:encoding_set = 1
      execute "edit ++enc=" . a:encoding
   endif
endfunction


" http://lwn.net/Articles/226514/

augroup gpg
" Remove ALL autocommands for the current group.
autocmd!
autocmd BufReadPre,FileReadPre *.gpg set viminfo=
autocmd BufReadPre,FileReadPre *.gpg setlocal noswapfile
autocmd BufReadPost *.gpg :%!gpg -q -d
autocmd BufReadPost *.gpg | redraw
autocmd BufWritePre *.gpg :%!gpg --default-recipient-self -q -e -a
autocmd BufWritePost *.gpg u
autocmd VimLeave *.gpg :!clear
" For OpenSSL:
" BufReadPost: use "openssl bf -d -a"
" BufWritePre: use "openssl bf -salt -a"
augroup END


function! SetWrap()
   setlocal wrap
   map <Up> gk
   imap <Up> <C-O>gk
   map <Down> gj
   imap <Down> <C-O>gj
   let b:wrap = 1
endfunction

function! SetNoWrap()
   setlocal nowrap
   map <Up> k
   map <Down> j
   let b:wrap = 0
endfunction

command! SetWrap call SetWrap()
command! SetNoWrap call SetNoWrap()

" b:wrap can be set by an ftplugin
autocmd BufReadPost * if !exists("b:wrap") | call SetWrap() | endif


" MAPPINGS

" Do not unindent #-comment
inoremap # X<C-H>#

" map <C-A> <Home>
" map <C-E> <End>
" map <C-Z> :shell<CR>


if version >= 700
" WEB BROWSERS

let s:URL_re="\\v(((https?|ftp|gopher|telnet)://|(mailto|file|news|about|ed2k|irc|sip|magnet):)[^' \t<>\"]+|(www|web|w3)[a-z0-9_-]*\\.[a-z0-9._-]+\\.[^' \t<>\"]+)[a-z0-9/]\\c"

function! ExtractURL()
   let line = getline('.')
   let parts = split(line, s:URL_re . '\zs')

   if len(parts) == 0
      throw 'ExtractURLCannotFindURL' " No URL found
   endif

   let length = 0
   let column = col('.')

   for p in parts
      let save_length = length
      let length += len(p)
      if length >= column
         break
      endif
   endfor

   let pos = match(p, s:URL_re)
   if pos == -1
      throw 'ExtractURLCannotFindURL' " No URL found
   endif

   if save_length + pos >= column " cursor left of the URL
      throw 'ExtractURLCannotFindURL'
   endif

   return strpart(p, pos)
endfunction

function! EscapeURL(url)
   let url = substitute(a:url, ' ', '%20', 'g')
   return escape(url, '!#$%')
endfunction

function! OpenURL(url, newwin)
   execute "!webbrowser " . a:newwin . " '" . EscapeURL(a:url) . "'"
endfunction

function! ExtractOpenURL(newwin)
   try
      let url = ExtractURL()
   catch /^ExtractURLCannotFindURL$/
      echoerr 'No URL found under cursor'
      return
   endtry

   call OpenURL(url, a:newwin)
endfunction

function! EncodeOpenURL(url, newwin)
   execute "!webbrowser-encode-url " . a:newwin . " '" . EscapeURL(a:url) . "'"
endfunction


" Send current link to a browser
nmap \b :call ExtractOpenURL('')<CR>
nmap \w :call ExtractOpenURL('-n')<CR>
nmap \t :call ExtractOpenURL('-t')<CR>
" Send visual block to a browser
vmap \b ""y:call OpenURL('<C-R>"', '')<CR>
vmap \w ""y:call OpenURL('<C-R>"', '-n')<CR>
vmap \t ""y:call OpenURL('<C-R>"', '-t')<CR>
" Encode and send visual block to a browser
vmap \B ""y:call EncodeOpenURL('<C-R>"', '')<CR>
vmap \W ""y:call EncodeOpenURL('<C-R>"', '-n')<CR>
vmap \T ""y:call EncodeOpenURL('<C-R>"', '-t')<CR>
" Send current file's name to a browser
nmap \B :call EncodeOpenURL('file:' . expand("%:p"), '')<CR>
nmap \W :call EncodeOpenURL('file:' . expand("%:p"), '-n')<CR>
nmap \T :call EncodeOpenURL('file:' . expand("%:p"), '-t')<CR>

endif " version >= 700


" SPELLING

if has("spell") " Works in 7.0+
   " Use builtin spellchecker
   nmap \sv :syntax off <BAR> setlocal spell<CR>
   " Clear
   nmap \sn :syntax on <BAR> setlocal nospell<CR>
endif


" Russian letters mapped in normal mode
"if has("keymap")
"   set keymap=russian-jcuken
"endif

if has("langmap")
   if v:version >= 702
      " langmap in utf-8 mode requires at least Vim 7.2.109
      scriptencoding utf-8
      set langmap=я<91>`п<81>~п╧qя<86>wя<83>eп╨rп╣tп╫yпЁuя<88>iя<89>oп╥pя<85>[я<8a>]я<84>aя<8b>sп╡dп╟fп©gя<80>hп╬jп╩kп╢lп╤\\;я<8d>'
                 \я<8f>zя<87>xя<81>cп╪vп╦bя<82>nя<8c>mп╠\\,я<8e>.п<99>Qп╕WпёEп<9a>Rп<95>Tп<9d>Yп<93>Uп╗Iп╘Oп<97>Pп╔{п╙}
                 \п╓Aп╚Sп<92>Dп<90>Fп<9f>Gп<a0>Hп<9e>Jп<9b>Kп<94>Lп<96>:п╜\\"п╞Zп╖Xп║Cп<9c>Vп<98>Bп╒Nп╛Mп<91><п╝>

   elseif &encoding != 'utf-8'
      scriptencoding koi8-r
      set langmap=ё`Ё~йqцwуeкrеtнyгuшiщoзpх[ъ]фaыsвdаfпgрhоjлkдlж\\;э'
                 \яzчxсcмvиbтnьmб\\,ю.ЙQЦWУEКRЕTНYГUШIЩOЗPХ{Ъ}
                 \ФAЫSВDАFПGРHОJЛKДLЖ:Э\\"ЯZЧXСCМVИBТNЬMБ<Ю>
   endif

   scriptencoding us-ascii
endif


if version >= 700
function! W()
   " let encodings=filter(split(&fileencodings, ','), 'v:val != "ucs-bom"')
   let encodings = ['us-ascii']
   if $LC_CTYPE == 'ru_RU.UTF-8'
      let encodings += ['utf-8']
   elseif $LC_CTYPE == 'ru_RU.KOI8-R'
      let encodings += ['koi8-r', 'utf-8']
   elseif v:lc_time == 'Russian_Russia.1251'
      let encodings += ['cp1251', 'utf-8']
   endif

   for e in encodings
      try
         execute 'set fileencoding=' . e
         w
         break
      catch /E513: write error, conversion failed/
         continue
      endtry
   endfor

   if &modified
      throw '"' . expand('%') . '" E513: write error, conversion failed; tried ' . join(encodings, ',')
   elseif has("spell")
      call SetupSpell()
   endif
endfunction

command! W call W()
endif


function! SlowTerm()
   set laststatus=1
   set noruler
   set shortmess=aoOtT
   set noshowcmd
   set scrolljump=5 " The minimal number of lines to scroll vertically when the cursor gets of the screen
   set sidescroll=5
   set nottyfast
   set notitle
   set timeoutlen=5000
   set nowildmenu
   set wildmode=list:longest
   set viminfo=!,h,'10,<100,s5
   syntax off
   highlight NonText cterm=NONE ctermfg=NONE
endfunction

if exists("$SLOWTERM")
   call SlowTerm()
endif


" ----------
" From http://slobin.pp.ru/vim/_vimrc.html

" These options will be kept between editing sessions
" let options = []

" Called automagically after .viminfo and plugins are loaded, sets
" miscellaneous options from persistent global variables
" function! VimEnter()
  " for optname in g:options
  "   let varname = "g:OPT_" . toupper(optname)
  "   if exists(varname)
  "     execute "let &" . optname . " = " . varname
  "   endif
  " endfor

  " if has("gui_running") && exists("g:WINPOSX") && exists("g:WINPOSY")
  "   execute "winpos" g:WINPOSX g:WINPOSY
  " endif
" endfunction

" Called automagically before .viminfo is saved, saves miscellaneous
" options into persistent global variables
" function! VimLeavePre()
  " call filter(g:, 'v:key !~# "^OPT_"')
  " for optname in g:options
  "   let varname = "g:OPT_" . toupper(optname)
  "   execute "let " . varname . " = &g:" . optname
  " endfor

  " if has("gui_running")
  "   let g:WINPOSX = getwinposx()
  "   let g:WINPOSY = getwinposy()
  " endif
" endfunction

" autocmd VimEnter * call VimEnter()
" autocmd VimLeavePre * call VimLeavePre()


" Called automagically after every buffer read, enables fileencoding
" setting from modeline (see Tip #911)
function! AutoEncoding()
  if exists("b:justloaded")
    unlet b:justloaded
    if &modified && &fileencoding != ""
      call SetupEncoding(&fileencoding)
    endif
  endif
endfunction

" Magic autocommands installed here
autocmd BufReadPost * let b:justloaded = 1
autocmd BufWinEnter * call AutoEncoding()


let CONVERT=1

" Value of a character under cursor; better than standard '0x%02B (%b)'
function! HexDec()
  let char = matchstr(getline("."), ".", col(".") - 1)
  if g:CONVERT
    let char = iconv(char, &encoding, &fileencoding)
    let format = "0x%02X <%d>"
  else
    let format = "0x%02X (%d)"
  endif
  let char = char2nr(char)
  return printf(format, char, char)
endfunction


if has("iconv")
   " Helper function for :DecodeQP and :DecodeURL commands
   function! DecodeHex(arg)
     return iconv(printf("%c", str2nr(submatch(1), 16)), a:arg, &encoding)
   endfunction

   " Custom completion for encoding names
   function! EncList(ArgLead, CmdLine, CursorPos)
     return filter(split(&fileencodings, ','),
                 \ "strpart(v:val, 0, strlen(a:ArgLead)) == a:ArgLead")
   endfunction

   if version >= 700
   " Command for decoding qp-encoded text
   command! -bar -nargs=? -range -complete=customlist,EncList DecodeQP
          \ <line1>,<line2>s/=\(\x\x\|\n\)/\=DecodeHex(<q-args>)/eg

   " Command for decoding url-encoded text
   command! -bar -nargs=? -range -complete=customlist,EncList DecodeURL
          \ <line1>,<line2>s/%\(\x\x\)/\=DecodeHex(<q-args>)/eg
   endif
endif


if has("spell")
   function! SetupSpell()
      if &fileencoding =~ 'ascii'
         setlocal spelllang=en spellfile=~/.vim/spell/en.ascii.add
      elseif &fileencoding == 'koi8-r'
         setlocal spelllang=en,ru spellfile=~/.vim/spell/en.ascii.add,~/.vim/spell/ru.koi8-r.add
      elseif &fileencoding == 'utf-8'
         setlocal spelllang=en,ru spellfile=~/.vim/spell/en.ascii.add,~/.vim/spell/ru.utf-8.add
      else
         setlocal spelllang= spellfile=
      endif
   endfunction
   autocmd BufReadPost * call SetupSpell()
endif


function! SyntaxName()
  echomsg synIDattr(synID(line("."), col("."), 1), "name")
endfunction


if has("python")

python << END_OF_PYTHON

import sys, rlcompleter, unicodedata, vim
from itertools import *
vim_complete = rlcompleter.Completer().complete

def vim_comp_list():
  """Implementation of CompList() function"""
  arglead = vim.eval("a:ArgLead")
  fence = int(vim.eval("match(a:ArgLead, '\(\w\|\.\)*$')"))
  left, right = arglead[:fence], arglead[fence:]
  try:
    completions = (vim_complete(right, i) for i in count())
    candidates = list(takewhile(bool, completions))
  except NameError:
    candidates = []
  suggestions = [left + x for x in candidates]
  vim.command("return " + repr(suggestions))

def vim_calc(command):
  """Implementation of :Calc command"""
  global _
  try:
    result = eval(command)
  except SyntaxError:
    exec command in globals()
  else:
    if result != None:
      print result
      _ = result
      xx = ''.join('\\x%02x' % ord(x) for x in str(_))
      vim.command('let @" = "%s"' % xx)

def vim_pydo(command):
  """Implementation of :Pydo command"""
  codeobj = compile(command, "command", "eval")
  line1 = vim.current.range.start
  line2 = vim.current.range.end
  delta = 0
  for numz in range(line1, line2+1):
    line = vim.current.buffer[numz-delta]
    uline = unicode(line, vim.eval('&fileencoding'))
    num = numz + 1
    words = line.split()
    result = eval(codeobj, globals(), locals())
    if result is None or result is False:
      del vim.current.buffer[numz-delta]
      delta += 1
      continue
    if isinstance(result, list) or isinstance(result, tuple):
      result = " ".join(map(str, result))
    else:
      result = str(result)
    vim.current.buffer[numz-delta] = result

def vim_unicode_name():
  try:
    char = vim.eval("matchstr(getline('.'), '.', col('.') - 1)")
    print map(unicodedata.name, char.decode(vim.eval("&encoding")))
  except (AttributeError, ValueError), target:
    print "%s: %s" % (target.__class__.__name__, target.message)

END_OF_PYTHON

" Custom completion for python expressions
function! CompList(ArgLead, CmdLine, CursorPos)
  python vim_comp_list()
endfunction

" Python command line calculator
command! -nargs=+ -range -complete=customlist,CompList Calc
       \ <line1>,<line2> python vim_calc(<q-args>)

" Python text range filter
command! -nargs=+ -range -complete=customlist,CompList Pydo
       \ <line1>,<line2> python vim_pydo(<q-args>)

" Display unicode name for the character under cursor
command! Uname python vim_unicode_name()
command! UName call Uname()

endif
" ----------


" This has to go to the very end of ~/.vimrc to allow reading the .vimrc
set secure        " safer working with script files in the current directory